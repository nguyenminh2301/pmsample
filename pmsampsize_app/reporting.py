
import streamlit as st
import pandas as pd
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from io import BytesIO
import markdown
from jinja2 import Environment, FileSystemLoader, select_autoescape
import os
from datetime import datetime

# Setup Jinja2
TEMPLATE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates')
env = Environment(
    loader=FileSystemLoader(TEMPLATE_DIR),
    autoescape=select_autoescape(['html', 'xml'])
)

def generate_report_html(context, df_results, T):
    """
    Generates an HTML report using Jinja2 templates.
    """
    template = env.get_template('generic_report.html')
    
    # Format current time
    now = datetime.now()
    date_str = now.strftime("%Y-%m-%d %H:%M:%S")
    
    # Convert DF to HTML with styling classes if possible, or just raw HTML
    if df_results is not None and not df_results.empty:
        results_html = df_results.to_html(index=False, classes="table table-striped", border=0)
    else:
        results_html = None
        
    render_ctx = {
        "lang": "en", # default, could be dynamic
        "title": T.get('title', 'PMSampSize'),
        "report_title": T.get('report_title', 'Sample Size Calculation Report'),
        "app_name": "Prognostic Research Sample Size App",
        "date_label": "Date",
        "date": date_str,
        "footer_text": T.get('footer_text', 'For research purposes only.'),
        
        "method_title": context.get('method_title', 'Unknown Method'),
        "method_description": context.get('method_description', ''),
        "inputs_title": T.get('riley_inputs', 'Input Parameters'),
        "inputs": context.get('inputs', {}),
        "results_title": T.get('results', 'Results'),
        "results_html": results_html
    }
    
    return template.render(**render_ctx)


def generate_report_markdown(context, df_results, T):
    """
    Generates a markdown report string.
    
    Args:
        context: dict containing 'method_title', 'inputs' (dict), 'timestamp'.
        df_results: DataFrame of results.
        T: Translation dictionary.
    """
    if df_results is None or df_results.empty:
        return "No results to report."
        
    md = f"# {T.get('report_header', 'Report')}\n\n"
    md += f"**{T.get('title', 'Prognostic Research Sample Size Tool')}**\n\n"
    md += f"**Method**: {context.get('method_title', 'Unknown')}\n\n"
    
    # Inputs
    md += f"## {T.get('riley_inputs', 'Inputs')}\n"
    for k, v in context.get('inputs', {}).items():
        md += f"- **{k}**: {v}\n"
    md += "\n"
    
    # Results Summary
    md += f"## {T.get('results', 'Results')}\n"
    
    # Convert DF to markdown table
    md += df_results.to_markdown(index=False)
    md += "\n\n"
    
    md += "---\n"
    md += f"Generated by PMSampSize App."
    
    return md

def send_email(to_email, subject, body_markdown, df_results=None, sender_email=None, sender_password=None):
    """
    Sends an email using SMTP (Gmail default).
    """
    if not sender_email or not sender_password:
        return False, "Sender credentials missing."
        
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = to_email
    msg['Subject'] = subject
    
    # Body (HTML)
    # Convert markdown to HTML for email body
    html_body = markdown.markdown(body_markdown, extensions=['tables'])
    # Wrap in simple HTML structure
    full_html = f"<html><body>{html_body}</body></html>"
    
    msg.attach(MIMEText(full_html, 'html'))
    
    # Attachment (CSV)
    if df_results is not None:
        csv_buffer = BytesIO()
        df_results.to_csv(csv_buffer, index=False)
        csv_buffer.seek(0)
        
        part = MIMEApplication(csv_buffer.read(), Name="results.csv")
        part['Content-Disposition'] = 'attachment; filename="results.csv"'
        msg.attach(part)
        
    try:
        # Connect to Gmail SMTP
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(sender_email, sender_password)
        text = msg.as_string()
        server.sendmail(sender_email, to_email, text)
        server.quit()
        return True, "Success"
    except Exception as e:
        return False, str(e)

def render_report_ui(context, df_results, T):
    """
    Renders the Report & Download UI section.
    """
    st.markdown("---")
    st.header(T.get("report_header", "Report & Downloads"))
    
    # 1. Refresh / Reset Button
    # This button allows the user to clear the current calculation state to start over
    if "refresh_key" in context and context["refresh_key"]:
        if st.button(f"üîÑ {T.get('btn_refresh', 'Refresh')}", key="btn_refresh_res"):
            # Clear specific session state results
            for k in context["refresh_key"]:
                if k in st.session_state:
                    del st.session_state[k]
            st.rerun()

    col_d1, col_d2 = st.columns(2)
    
    # 2. Download HTML (Formatted Report)
    with col_d1:
        try:
            html_content = generate_report_html(context, df_results, T)
            st.download_button(
                label=f"üåê {T.get('btn_download_html', 'Download Report (HTML)')}",
                data=html_content,
                file_name="pmsampsize_report.html",
                mime="text/html"
            )
        except Exception as e:
            st.error(f"Could not generate HTML report: {e}")

    # 3. Download CSV (Result)
    with col_d2:
        csv = df_results.to_csv(index=False).encode('utf-8')
        st.download_button(
            label=f"üìä {T.get('btn_download_csv', 'Download CSV')}",
            data=csv,
            file_name='pmsampsize_results.csv',
            mime='text/csv'
        )
    
    
    # 2. Download HTML (Formatted Report)
    try:
        html_content = generate_report_html(context, df_results, T)
        st.download_button(
            label=f"üåê {T.get('btn_download_html', 'Download Report (HTML)')}",
            data=html_content,
            file_name="pmsampsize_report.html",
            mime="text/html"
        )
    except Exception as e:
        st.error(f"Could not generate HTML report: {e}")

    # Downloads handled in columns above
    
    # 4. Email Section - DISABLED by user request
    # with st.expander(f"üìß {T.get('email_header', 'Email Results')}"):
    #     
    #     # User credentials (simple approach: stored in session state for session duration)
    #     if "email_sender" not in st.session_state:
    #         st.session_state["email_sender"] = ""
    #     if "email_password" not in st.session_state:
    #         st.session_state["email_password"] = ""
    #         
    #     col1, col2 = st.columns(2)
    #     with col1:
    #          sender = st.text_input(T.get("email_sender", "Your Email"), value=st.session_state["email_sender"], key="rpt_sender")
    #     with col2:
    #          pwd = st.text_input(T.get("email_password", "App Password"), value=st.session_state["email_password"], type="password", help="Use an App Password for Gmail", key="rpt_pwd")
    #          
    #     # Update session state
    #     st.session_state["email_sender"] = sender
    #     st.session_state["email_password"] = pwd
    #     
    #     st.markdown("---")
    #     
    #     recipient = st.text_input(T.get("email_to", "Recipient Email"))
    #     
    #     if st.button(T.get("email_send_btn", "Send Email"), type="primary", disabled=(not sender or not pwd or not recipient)):
    #         with st.spinner("Sending..."):
    #             subject = T.get("email_subject_default", "Analysis Results")
    #             success, msg = send_email(recipient, subject, report_md, df_results, sender, pwd)
    #             
    #             if success:
    #                 st.success(T.get("email_success", "Sent!"))
    #             else:
    #                 st.error(f"{T.get('email_error', 'Error')}: {msg}")
